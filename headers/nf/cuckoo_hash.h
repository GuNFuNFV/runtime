
#ifndef NFLAMBDA_RUNTIME_CUCKOOHASH_H
#define NFLAMBDA_RUNTIME_CUCKOOHASH_H

#include "fsm_amac_nf_common.h"
#include "../custom_hash.h"

struct cuckoo_state {
    CONTROL_VARIABLE_OFFSET cuckoo_hash_key_offset;
    CONTROL_VARIABLE_OFFSET prim_bucket_idx_offset;
    CONTROL_VARIABLE_OFFSET alt_bucket_idx_offset;
    CONTROL_VARIABLE_OFFSET short_sig_offset;

    int cuckoo_hash_entry_num;
    int cuckoo_hash_key_size;
    uint8_t cuckoo_hash_header_type;

    // generated by the configuration
    // to access the data in the message, which is shared among all the actors
    // this not configurable
    // decides locally

    EVENT cuckoo_hash_get_key_done;
    EVENT cuckoo_hash_first_hash_done;
    EVENT cuckoo_hash_first_test_failure;
    EVENT cuckoo_hash_second_hash_done;
    EVENT cuckoo_hash_test_success;


    // core id
    int core_id; // unfortunate workaround for now
};


INLINE_ACTOR_ACTION(cuckoo_hash_rtc) {
    struct five_tuple fiveTuple;
    struct cuckoo_state *cuckooState = m->control_state;

    struct rte_ipv4_hdr *ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*,
                                                            sizeof(struct rte_ether_hdr));
    struct rte_tcp_hdr *tcpHdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_tcp_hdr*,
                                                         sizeof(struct rte_ether_hdr) + sizeof(struct rte_ipv4_hdr));
    fiveTuple.src_ip = (ipv4_hdr->src_addr);
    fiveTuple.dst_ip = (ipv4_hdr->dst_addr);
    fiveTuple.src_port = (0);
    fiveTuple.dst_port = (0);
//    fiveTuple.proto = IPPROTO_TCP;
    struct rte_hash *hash;
    hash = m->data_state;
    int ret;
    ret = rte_hash_lookup(hash, &fiveTuple);
    if (ret < 0) {
        // dump the 5-tuple using host byte order
        printf("fiveTuple.src_ip is %u\n", rte_be_to_cpu_32(fiveTuple.src_ip));
        printf("fiveTuple.dst_ip is %u\n", rte_be_to_cpu_32(fiveTuple.dst_ip));
        printf("fiveTuple.src_port is %u\n", rte_be_to_cpu_16(fiveTuple.src_port));
        printf("fiveTuple.dst_port is %u\n", rte_be_to_cpu_16(fiveTuple.dst_port));
        // core id
        printf("core id is %d\n", cuckooState->core_id);
        fflush(stdout);
//        printf("fiveTuple.proto is %u\n", fiveTuple.proto);
        m->event = 255;
        rte_pktmbuf_free(m->packet);
//        m->local_offset[m->datablock_id + 1] = ret;
        return;
    } else {
//        printf("found the key\n");
//        fflush(stdout);
        m->event = cuckooState->cuckoo_hash_test_success;
        m->local_offset[m->datablock_id + 1] = ret;
        return;
    }
}

INLINE_ACTOR_ACTION(cuckoo_hash_get_key) {

    struct five_tuple fiveTuple;
    struct cuckoo_state *cuckooState = m->control_state;

    struct rte_ipv4_hdr *ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*,
                                                            sizeof(struct rte_ether_hdr));
    struct rte_tcp_hdr *tcp_hdr;
    switch (cuckooState->cuckoo_hash_header_type) {
        case FIVE_TUPLE:
            ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*, sizeof(struct rte_ether_hdr));
            rte_prefetch0(ipv4_hdr);
            rte_prefetch0(ipv4_hdr + 1);
            break;
        case SRC_IP:
            break;
    }
    m->event = cuckooState->cuckoo_hash_get_key_done;
}

INLINE_ACTOR_ACTION(cuckoo_hash_first_hash) {
//    DEBUG_PRINT("cuckoo_hash_first_hash\n");
    struct cuckoo_state *cuckooState = m->control_state;
    struct rte_ipv4_hdr *ipv4_hdr;
    struct rte_tcp_hdr *tcp_hdr;
    ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*, sizeof(struct rte_ether_hdr));
    tcp_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_tcp_hdr*,
                                      sizeof(struct rte_ipv4_hdr) + sizeof(struct rte_ether_hdr));
    struct five_tuple *five_tuple = &(m->buffer.data[((struct cuckoo_state *) m->control_state)->cuckoo_hash_key_offset]);
    five_tuple->src_ip = ipv4_hdr->src_addr;
    five_tuple->dst_ip = ipv4_hdr->dst_addr;
//    five_tuple->src_port = rte_be_to_cpu_16((uint16_t)cuckooState->core_id);
    five_tuple->src_port = 0;
    five_tuple->dst_port = 0;
//    five_tuple->proto = ipv4_hdr->next_proto_id;
//    DEBUG_PRINT("five tuple is %u, %u, %u, %u, %u on core %d\n", rte_be_to_cpu_32(five_tuple->src_ip),
//                rte_be_to_cpu_32(five_tuple->dst_ip), rte_be_to_cpu_16(five_tuple->src_port),
//                rte_be_to_cpu_16(five_tuple->dst_port), five_tuple->proto, rte_lcore_id());
    hash_sig_t sig;
    // get the first hash
    sig = rte_jhash(five_tuple, sizeof(struct five_tuple), 0);

    uint32_t *prim_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->prim_bucket_idx_offset]);
    *prim_bucket_idx = get_prim_bucket_index((struct rte_hash *) m->data_state, sig);
    struct rte_hash_bucket *bkt;
    bkt = &(((struct rte_hash *) m->data_state)->buckets[*prim_bucket_idx]);
    rte_prefetch0(bkt); // prefetch the bucket
    // get the short signature
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    *short_sig = get_short_sig(sig);
    m->event = cuckooState->cuckoo_hash_first_hash_done;
}

INLINE_ACTOR_ACTION(cuckoo_hash_first_test) {
    struct cuckoo_state *cuckooState = m->control_state;
//    DEBUG_PRINT("cuckoo_hash_first_test\n");
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    uint32_t *prim_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->prim_bucket_idx_offset]);
    struct rte_hash_bucket *bkt;
    bkt = &(((struct rte_hash *) m->data_state)->buckets[*prim_bucket_idx]);
    // check __rte_hash_lookup_with_hash_l
    // get the key
    struct five_tuple *five_tuple = (struct five_tuple *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->cuckoo_hash_key_offset]);
//    DEBUG_PRINT("src_ip %u\n", five_tuple->src_ip);
    int ret = search_one_bucket_l(((struct rte_hash *) m->data_state), five_tuple, *short_sig, NULL, bkt);
    if (ret >= 0) {
//        DEBUG_PRINT("first test success\n");
        m->event = ((struct cuckoo_state *) m->control_state)->cuckoo_hash_test_success;
//        m->event = paths[amac_send_packet_path];
        m->local_offset[m->datablock_id + 1] = ret;
//        DEBUG_PRINT("ret %d\n", ret);
    } else m->event = cuckooState->cuckoo_hash_first_test_failure;
}

INLINE_ACTOR_ACTION(cuckoo_hash_second_hash) {
    struct cuckoo_state *cuckooState = m->control_state;
    struct rte_hash *hash = m->data_state;
    // get the second hash
    uint32_t *alt_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->alt_bucket_idx_offset]);
    uint32_t *prim_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->prim_bucket_idx_offset]);
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    *alt_bucket_idx = get_alt_bucket_index(hash, *prim_bucket_idx, *short_sig);
    rte_prefetch0(&(hash->buckets[*alt_bucket_idx]));
    m->event = cuckooState->cuckoo_hash_second_hash_done;
}

INLINE_ACTOR_ACTION(cuckoo_hash_second_test) {
    struct rte_hash *hash = m->data_state;
    uint32_t *alt_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->alt_bucket_idx_offset]);
    struct rte_hash_bucket *bkt;
    bkt = &(hash->buckets[*alt_bucket_idx]);
    struct five_tuple *five_tuple = (struct five_tuple *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->cuckoo_hash_key_offset]);
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    int ret = search_one_bucket_l(hash, five_tuple, *short_sig, NULL, bkt);
    if (ret >= 0) {
//        DEBUG_PRINT("cuckoo_hash_second_test success\n");
        m->event = ((struct cuckoo_state *) m->control_state)->cuckoo_hash_test_success;
        m->local_offset[m->datablock_id + 1] = ret;
    } else {
        DEBUG_PRINT("cuckoo_hash_second_test failure\n");
//        m->event = 255;
//        rte_pktmbuf_free(m->packet);
        m->event = ((struct cuckoo_state *) m->control_state)->cuckoo_hash_test_success;
        m->local_offset[m->datablock_id + 1] = 0;
    }
}


INLINE_ACTOR_ACTION(cuckoo_hash_get_key_non_temporal) {

    struct five_tuple fiveTuple;
    struct cuckoo_state *cuckooState = m->control_state;

    struct rte_ipv4_hdr *ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*,
                                                            sizeof(struct rte_ether_hdr));
    struct rte_tcp_hdr *tcp_hdr;
    switch (cuckooState->cuckoo_hash_header_type) {
        case FIVE_TUPLE:
            ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*, sizeof(struct rte_ether_hdr));
            rte_prefetch_non_temporal(ipv4_hdr);
            rte_prefetch_non_temporal(ipv4_hdr + 1);
            break;
        case SRC_IP:
            break;
    }
    m->event = cuckooState->cuckoo_hash_get_key_done;
}

INLINE_ACTOR_ACTION(cuckoo_hash_first_hash_non_temporal) {
//    DEBUG_PRINT("cuckoo_hash_first_hash\n");
    struct cuckoo_state *cuckooState = m->control_state;
    struct rte_ipv4_hdr *ipv4_hdr;
    struct rte_tcp_hdr *tcp_hdr;
    ipv4_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_ipv4_hdr*, sizeof(struct rte_ether_hdr));
    tcp_hdr = rte_pktmbuf_mtod_offset(m->packet, struct rte_tcp_hdr*,
                                      sizeof(struct rte_ipv4_hdr) + sizeof(struct rte_ether_hdr));
    struct five_tuple *five_tuple = &(m->buffer.data[((struct cuckoo_state *) m->control_state)->cuckoo_hash_key_offset]);
    five_tuple->src_ip = ipv4_hdr->src_addr;
    five_tuple->dst_ip = ipv4_hdr->dst_addr;
//    five_tuple->src_port = rte_be_to_cpu_16((uint16_t)cuckooState->core_id);
    five_tuple->src_port = tcp_hdr->src_port;
    five_tuple->dst_port = 0;
//    five_tuple->proto = ipv4_hdr->next_proto_id;
//    DEBUG_PRINT("five tuple is %u, %u, %u, %u, %u on core %d\n", rte_be_to_cpu_32(five_tuple->src_ip),
//                rte_be_to_cpu_32(five_tuple->dst_ip), rte_be_to_cpu_16(five_tuple->src_port),
//                rte_be_to_cpu_16(five_tuple->dst_port), five_tuple->proto, rte_lcore_id());
    hash_sig_t sig;
    // get the first hash
    sig = rte_jhash(five_tuple, sizeof(struct five_tuple), 0);

    uint32_t *prim_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->prim_bucket_idx_offset]);
    *prim_bucket_idx = get_prim_bucket_index((struct rte_hash *) m->data_state, sig);
    struct rte_hash_bucket *bkt;
    bkt = &(((struct rte_hash *) m->data_state)->buckets[*prim_bucket_idx]);
    rte_prefetch_non_temporal(bkt); // prefetch the bucket
    // get the short signature
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    *short_sig = get_short_sig(sig);
    m->event = cuckooState->cuckoo_hash_first_hash_done;
}

INLINE_ACTOR_ACTION(cuckoo_hash_first_test_non_temporal) {
    struct cuckoo_state *cuckooState = m->control_state;
//    DEBUG_PRINT("cuckoo_hash_first_test\n");
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    uint32_t *prim_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->prim_bucket_idx_offset]);
    struct rte_hash_bucket *bkt;
    bkt = &(((struct rte_hash *) m->data_state)->buckets[*prim_bucket_idx]);
    // check __rte_hash_lookup_with_hash_l
    // get the key
    struct five_tuple *five_tuple = (struct five_tuple *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->cuckoo_hash_key_offset]);
//    DEBUG_PRINT("src_ip %u\n", five_tuple->src_ip);
    int ret = search_one_bucket_l(((struct rte_hash *) m->data_state), five_tuple, *short_sig, NULL, bkt);
    if (ret >= 0) {
//        DEBUG_PRINT("first test success\n");
        m->event = ((struct cuckoo_state *) m->control_state)->cuckoo_hash_test_success;
//        m->event = paths[amac_send_packet_path];
        m->local_offset[m->datablock_id + 1] = ret;
//        DEBUG_PRINT("ret %d\n", ret);
    } else m->event = cuckooState->cuckoo_hash_first_test_failure;
}

INLINE_ACTOR_ACTION(cuckoo_hash_second_hash_non_temporal) {
    struct cuckoo_state *cuckooState = m->control_state;
    struct rte_hash *hash = m->data_state;
    // get the second hash
    uint32_t *alt_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->alt_bucket_idx_offset]);
    uint32_t *prim_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->prim_bucket_idx_offset]);
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    *alt_bucket_idx = get_alt_bucket_index(hash, *prim_bucket_idx, *short_sig);
    rte_prefetch_non_temporal(&(hash->buckets[*alt_bucket_idx]));
    m->event = cuckooState->cuckoo_hash_second_hash_done;
}

INLINE_ACTOR_ACTION(cuckoo_hash_second_test_non_temporal) {
    struct rte_hash *hash = m->data_state;
    uint32_t *alt_bucket_idx = (uint32_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->alt_bucket_idx_offset]);
    struct rte_hash_bucket *bkt;
    bkt = &(hash->buckets[*alt_bucket_idx]);
    struct five_tuple *five_tuple = (struct five_tuple *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->cuckoo_hash_key_offset]);
    uint16_t *short_sig = (uint16_t *) &(m->buffer.data[((struct cuckoo_state *) m->control_state)->short_sig_offset]);
    int ret = search_one_bucket_l(hash, five_tuple, *short_sig, NULL, bkt);
    if (ret >= 0) {
//        DEBUG_PRINT("cuckoo_hash_second_test success\n");
        m->event = ((struct cuckoo_state *) m->control_state)->cuckoo_hash_test_success;
        m->local_offset[m->datablock_id + 1] = ret;
    } else {
        DEBUG_PRINT("cuckoo_hash_second_test failure\n");
//        m->event = 255;
//        rte_pktmbuf_free(m->packet);
        m->event = ((struct cuckoo_state *) m->control_state)->cuckoo_hash_test_success;
// send it anyway
    }
}



ACTOR_CONTROL_STATE_INIT(cuckoo_hash_init);

AMAC_CLASSIFIER_INIT(cuckoo_hash_classifier);

#endif //NFLAMBDA_RUNTIME_CUCKOOHASH_H
